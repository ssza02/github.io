{"meta":{"title":"叉烧范","subtitle":null,"description":"my blogs","author":"heng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"前端性能优化（下）","slug":"前端性能优化（下）","date":"2019-07-21T15:16:04.000Z","updated":"2019-07-21T15:27:48.340Z","comments":true,"path":"2019/07/21/前端性能优化（下）/","link":"","permalink":"http://yoursite.com/2019/07/21/前端性能优化（下）/","excerpt":"","text":"优化首屏体验–lazy load1234567891011121314151617181920212223&lt;script&gt; // 获取所有的图片标签 const imgs = document.getElementsByTagName(&apos;img&apos;) // 获取可视区域的高度 const viewHeight = window.innerHeight || document.documentElement.clientHeight // num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出 let num = 0 function lazyload()&#123; for(let i=num; i&lt;imgs.length; i++) &#123; // 用可视区域高度减去元素顶部距离可视区域顶部的高度 let distance = viewHeight - imgs[i].getBoundingClientRect().top // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出 if(distance &gt;= 0 )&#123; // 给元素写入真实的src，展示图片 imgs[i].src = imgs[i].getAttribute(&apos;data-src&apos;) // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出 num = i + 1 &#125; &#125; &#125; // 监听Scroll事件 window.addEventListener(&apos;scroll&apos;, lazyload, false);&lt;/script&gt; 事件截流与防抖 Throttle： 第一个人说了算 Debounce： 最后一个人说了算 我们对比 throttle 来理解 debounce：在throttle的逻辑里，“第一个人说了算”，它只为第一个乘客计时，时间到了就执行回调。而 debounce 认为，“最后一个人说了算”，debounce 会为每一个新乘客设定新的定时器。 ==debounce 强制函数在某段时间内只执行一次，throttle 强制函数以固定的速率执行。在处理一些高频率触发的 DOM 事件的时候，它们都能极大提高用户体验。==","categories":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/categories/前端优化/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/tags/前端优化/"}]},{"title":"前端性能优化（中）","slug":"前端性能优化（中）","date":"2019-07-21T14:17:03.000Z","updated":"2019-07-21T14:42:24.037Z","comments":true,"path":"2019/07/21/前端性能优化（中）/","link":"","permalink":"http://yoursite.com/2019/07/21/前端性能优化（中）/","excerpt":"客户端渲染 客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁 页面上呈现的内容，你在 html 源文件里找不到——这正是它的特点。 服务端渲染 服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。 使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。","text":"客户端渲染 客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁 页面上呈现的内容，你在 html 源文件里找不到——这正是它的特点。 服务端渲染 服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。 使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。 浏览器内核 浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（下文我们将沿用这种叫法）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。 目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。 这里面大家最耳熟能详的可能就是 Webkit 内核了。很多同学可能会听说过 Chrome 的内核就是 Webkit，殊不知 Chrome 内核早已迭代为了 Blink。但是换汤不换药，Blink 其实也是基于 Webkit 衍生而来的一个分支，因此，Webkit 内核仍然是当下浏览器世界真正的霸主。 渲染过程 HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。 CSS 解释器：解析 CSS 文档, 生成样式规则。 图层布局计算模块：布局计算每个对象的精确位置和大小。 视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。 JavaScript 引擎：编译执行 Javascript 代码。 浏览器渲染过程解析 解析 HTML 在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。 计算样式 浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。 计算图层布局 页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。 绘制图层 在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。 整合图层，得到页面 最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。 渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。 Event Loop 中的“渲染时机” 宏任务：包括整体代码script，setTimeout，setInterval 微任务：Promise.then(非new Promise)，process.nextTick(node中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 1234567setTimeout(() =&gt; &#123; console.log(&apos;延时1秒&apos;);&#125;,1000)console.log(&quot;开始&quot;)输出：开始延时1秒 上述代码，setTimeout函数是宏任务，且是异步任务，因此会将函数放入Event Table并注册函数，经过指定时间后，把要执行的任务加入到Event Queue中，等待同步任务console.log(“开始”)执行结束后，读取Event Queue中setTimeout的回调函数执行。","categories":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/categories/前端优化/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/tags/前端优化/"}]},{"title":"vue常用插件","slug":"vue常用插件","date":"2019-01-05T14:26:08.000Z","updated":"2019-01-05T14:27:36.548Z","comments":true,"path":"2019/01/05/vue常用插件/","link":"","permalink":"http://yoursite.com/2019/01/05/vue常用插件/","excerpt":"一、UI组件及框架 element - 饿了么出品的Vue2的web UI工具套件 mint-ui - Vue 2的移动UI元素 iview - 基于 Vuejs 的开源 UI 组件库 Keen-UI - 轻量级的基本UI组件合集 vue-material - 通过Vue Material和Vue 2建立精美的app应用 muse-ui - 三端样式一致的响应式 UI 库","text":"一、UI组件及框架 element - 饿了么出品的Vue2的web UI工具套件 mint-ui - Vue 2的移动UI元素 iview - 基于 Vuejs 的开源 UI 组件库 Keen-UI - 轻量级的基本UI组件合集 vue-material - 通过Vue Material和Vue 2建立精美的app应用 muse-ui - 三端样式一致的响应式 UI 库 vuetify - 为移动而生的Vue JS 2组件框架 vonic - 快速构建移动端单页应用 vue-blu - 帮助你轻松创建web应用 vue-multiselect - Vue.js选择框解决方案 VueCircleMenu - 漂亮的vue圆环菜单 vue-chat - vuejs和vuex及webpack的聊天示例 radon-ui - 快速开发产品的Vue组件库 vue-waterfall - Vue.js的瀑布布局组件 vue-carbon - 基于 vue 开发MD风格的移动端 vue-beauty - 由vue和ant design创建的优美UI组件 bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 vueAdmin - 基于vuejs2和element的简单的管理员模板 vue-ztree - 用 vue 写的树层级组件 vue-tree - vue树视图组件 vue-tabs - 多tab页轻型框架二、滚动scroll组件 vue-scroller - Vonic UI的功能性组件 vue-mugen-scroll - 无限滚动组件 vue-infinite-loading - VueJS的无限滚动插件 vue-virtual-scroller - 带任意数目数据的顺畅的滚动 vue-infinite-scroll - VueJS的无限滚动指令 vue-scrollbar - 最简单的滚动区域组件 vue-scroll - vue滚动 vue-pull-to-refresh - Vue2的上拉下拉 mint-loadmore - VueJS的双向下拉刷新组件 vue-smoothscroll - smoothscroll的VueJS版本三、slider组件 vue-awesome-swiper - vue.js触摸滑动组件 vue-slick - 实现流畅轮播框的vue组件 vue-swipe - VueJS触摸滑块 vue-swiper - 易于使用的滑块组件 vue-images - 显示一组图片的lightbox组件 vue-carousel-3d - VueJS的3D轮播组件 vue-slide - vue轻量级滑动组件 vue-slider - vue 滑动组件 vue-m-carousel - vue 移动端轮播组件 dd-vue-component - 订单来了的公共组件库 vue-easy-slider - Vue 2.x的滑块组件四、编辑器 markcook - 好看的markdown编辑器 eme - 优雅的Markdown编辑器 vue-syntax-highlight - Sublime Text语法高亮 vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 Vueditor - 所见即所得的编辑器 vue-html5-editor - html5所见即所得编辑器 vue2-editor - HTML编辑器 vue-simplemde - VueJS的Markdown编辑器组件 vue-quill - vue组件构建quill编辑器五、图表 vue-table - 简化数据表格 vue-chartjs - vue中的Chartjs的封装 vue-charts - 轻松渲染一个图表 vue-chart - 强大的高速的vue图表解析 vue-highcharts - HighCharts组件 chartjs - Vue Bulma的chartjs组件 vue-chartkick - VueJS一行代码实现优美图表六、日历 vue-calendar - 日期选择插件 vue-datepicker - 日历和日期选择组件 vue-datetime-picker - 日期时间选择控件 vue2-calendar - 支持lunar和日期事件的日期选择器 vue-fullcalendar - 基于vue.js的全日历组件 vue-datepicker - 漂亮的Vue日期选择器组件 datepicker - 基于flatpickr的时间选择组件 vue2-timepicker - 下拉时间选择器 vue-date-picker - VueJS日期选择器组件 vue-datepicker-simple - 基于vue的日期选择器七、地址选择 vue-city - 城市选择器 vue-region-picker - 选择中国的省份市和地区八、地图 vue-amap - 基于Vue 2和高德地图的地图组件 vue-google-maps - 带有双向数据绑定Google地图组件 vue-baidu-map- 基于 Vue 2的百度地图组件库 vue-cmap - Vue China map可视化组件九、播放器 vue-video-player - VueJS视频及直播播放器 vue-video - Vue.js的HTML5视频播放器 vue-music-master - vue手机端网页音乐播放器十、文件上传 vue-upload-component - Vuejs文件上传组件 vue-core-image-upload - 轻量级的vue上传插件 vue-dropzone - 用于文件上传的Vue组件十一、图片处理 vue-lazyload-img - 移动优化的vue图片懒加载插件 vue-image-crop-upload - vue图片剪裁上传组件 vue-svgicon - 创建svg图标组件的工具 vue-img-loader - 图片加载UI组件 vue-image-clip- 基于vue的图像剪辑组件 vue-progressive-image - Vue的渐进图像加载插件十二、提示 vue-toast-mobile - VueJS的toast插件 vue-msgbox - vuejs的消息框 vue-tooltip - 带绑定信息提示的提示工具 vue-verify-pop - 带气泡提示的vue校验插件十三、进度条 vue-radial-progress - Vue.js放射性进度条组件 vue-progressbar - vue轻量级进度条 vue2-loading-bar - 最简单的仿Youtube加载条视图十四、开发框架汇总 vue-admin - Vue管理面板框架 electron-vue - Electron及VueJS快速启动样板 vue-2.0-boilerplate - Vue2单页应用样板 vue-webgulp - 仿VueJS Vue loader示例 vue-bulma - 轻量级高性能MVVM Admin UI框架 vue-spa-template - 前后端分离后的单页应用开发 Framework7-Vue - VueJS与Framework7结合 vue-element-starter - vue启动页十五、实用库汇总 vuelidate - 简单轻量级的基于模块的Vue.js验证 qingcheng - qingcheng主题 vuex - 专为 Vue.js 应用程序开发的状态管理模式 vue-axios - 将axios整合到VueJS的封装 vue-desktop - 创建管理面板网站的UI库 vue-meta - 管理app的meta信息 avoriaz - VueJS测试实用工具库 vue-framework7 - 结合VueJS使用的Framework7组件 vue-lazy-render - 用于Vue组件的延迟渲染 vue-svg-icon - vue2的可变彩色svg图标方案 vue-online - reactive的在线和离线组件 vue-password-strength-meter - 交互式密码强度计 vuep - 用实时编辑和预览来渲染Vue组件 vue-bootstrap-modal - vue的Bootstrap样式组件 element-admin - 支持 vuecli 的 Element UI 的后台模板 vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 cleave - 基于cleave.js的Cleave组件 vue-events - 简化事件的VueJS插件 http-vue-loader - 从html及js环境加载vue文件 vue-electron - 将选择的API封装到Vue对象中的插件 vue-router-transition - 页面过渡插件 vuemit - 处理VueJS事件 vue-cordova - Cordova的VueJS插件 vue-qart - 用于qartjs的Vue2指令 vue-websocket - VueJS的Websocket插件 vue-gesture - VueJS的手势事件插件 vue-local-storage - 具有类型支持的Vuejs本地储存插件 lazy-vue - 懒加载图片 vue-lazyloadImg - 图片懒加载插件 vue-bus - VueJS的事件总线 vue-observe-visibility - 当元素在页面上可见或隐藏时检测 vue-notifications - 非阻塞通知库 v-media-query - vue中添加用于配合媒体查询的方法 vuex-shared-mutations - 分享某种Vuex mutations vue-lazy-component - 懒加载组件或者元素的Vue指令 vue-reactive-storage - vue插件的Reactive层 vue-ts-loader - 在Vue装载机检查脚本 vue-pagination-2 - 简单通用的分页组件 vuex-i18n - 定位插件 Vue.resize - 检测HTML调整大小事件的vue指令 vue-zoombox - 一个高级zoombox leo-vue-validator - 异步的表单验证组件 modal - Vue Bulma的modal组件 Famous-Vue - Famous库的vue组件 vue-input-autosize - 基于内容自动调整文本输入的大小 vue-file-base64 - 将文件转换为Base64的vue组件 Vue-Easy-Validator - 简单的表单验证 vue-truncate-filter - 截断字符串的VueJS过滤器十六、服务端vue-ssr - 结合Express使用Vue2服务端渲染nuxt.js - 用于服务器渲染Vue app的最小化框架vue-ssr - 非常简单的VueJS服务器端渲染模板vue-easy-renderer - Nodejs服务端渲染express-vue - 简单的使用服务器端渲染vue.js十七、辅助工具 DejaVue - Vuejs可视化及压力测试 vue-generate-component - 轻松生成Vue js组件的CLI工具 vscode-VueHelper - 目前vscode最好的vue代码提示插件 vue-play - 展示Vue组件的最小化框架 VuejsStarterKit - vuejs starter套件 vue-multipage-cli - 简单的多页CLI十八、应用实例 pagekit - 轻量级的CMS建站系统 vuedo - 博客平台 koel - 基于网络的个人音频流媒体服务 CMS-of-Blog - 博客内容管理器 vue-cnode - 重写vue版cnode社区 vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim - Web版的聊天应用 fewords - 功能极其简单的笔记本 jackblog-vue - 个人博客系统 vue-blog - 使用Vue2.0 和Vuex的vue-blog vue-dashing-js - nuvo-dashing-js的fork rss-reader - 简单的rss阅读器","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"js","slug":"vue/js","permalink":"http://yoursite.com/categories/vue/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"filter、map、some、every等常用js数组方法","slug":"filter、map、some、every等常用js数组方法","date":"2018-12-07T16:39:24.000Z","updated":"2018-12-07T16:40:29.104Z","comments":true,"path":"2018/12/08/filter、map、some、every等常用js数组方法/","link":"","permalink":"http://yoursite.com/2018/12/08/filter、map、some、every等常用js数组方法/","excerpt":"filter():语法：1var filteredArray = array.filter(callback[, thisObject]); 用法：123456789//过滤掉小于 10 的数组元素：//代码：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// 12, 130, 44//结果：[12, 5, 8, 130, 44].filter(isBigEnough) ： 12, 130, 44","text":"filter():语法：1var filteredArray = array.filter(callback[, thisObject]); 用法：123456789//过滤掉小于 10 的数组元素：//代码：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// 12, 130, 44//结果：[12, 5, 8, 130, 44].filter(isBigEnough) ： 12, 130, 44 map():1234567891011//将所有的数组元素转换为大写：var strings = [&quot;hello&quot;, &quot;Array&quot;, &quot;WORLD&quot;];function makeUpperCase(v)&#123; return v.toUpperCase();&#125;var uppers = strings.map(makeUpperCase);// uppers is now [&quot;HELLO&quot;, &quot;ARRAY&quot;, &quot;WORLD&quot;]// strings is unchanged//结果：[&quot;hello&quot;, &quot;Array&quot;, &quot;WORLD&quot;].map(makeUpperCase) ： HELLO, ARRAY, WORLD some():对数组中的每个元素都执行一次指定的函数（callback），直到此函数返回 true，如果发现这个元素，some 将返回 true，如果回调函数对每个元素执行后都返回 false ，some 将返回 false。它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略。123456789101112//检查是否有数组元素大于等于10：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true//结果：//[2, 5, 8, 1, 4].some(isBigEnough) ： false//[12, 5, 8, 1, 4].some(isBigEnough) ： true every():对数组中的每个元素都执行一次指定的函数（callback），直到此函数返回 false，如果发现这个元素，every 将返回 false，如果回调函数对每个元素执行后都返回 true ，every 将返回 true。它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略123456789101112//测试是否所有数组元素都大于等于10：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true//结果：//[12, 5, 8, 130, 44].every(isBigEnough) 返回 ： false//[12, 54, 18, 130, 44].every(isBigEnough) 返回 ： true forEach():1234567891011121314//打印数组内容：function printElt(element, index, array) &#123; document.writeln(&quot;[&quot; + index + &quot;] is &quot; + element + &quot;&lt;br /&gt;&quot;);&#125;[2, 5, 9].forEach(printElt);// Prints:// [0] is 2// [1] is 5// [2] is 9//结果：//[0] is 2//[1] is 5//[2] is 9 indexOf 和 lastIndexOf的区别indexOf():indexOf 是查某个指定的字符串在字符串首次出现的位置（索引值） （也就是从前往后查）12345678910//查找符合条件的元素：var array = [2, 5, 9];var index = array.indexOf(2);// index is 0index = array.indexOf(7);// index is -1//结果：//[2, 5, 9].indexOf(2) ： 0//[2, 5, 9].indexOf(7) ： -1 lastIndexOf():lastIndexOf 是从右向左查某个指定的字符串在字符串中最后一次出现的位置（也就是从后往前查）12345678910111213141516171819202122//查找符合条件的元素：var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3//结果：//[2, 5, 9, 2].lastIndexOf(2) ： 3//[2, 5, 9, 2].lastIndexOf(7) ： -1//[2, 5, 9, 2].lastIndexOf(2, 3) ： 3//[2, 5, 9, 2].lastIndexOf(2, 2) ： 0//[2, 5, 9, 2].lastIndexOf(2, -2) ： 0//[2, 5, 9, 2].lastIndexOf(2, -1) ： 3 那么问题来了 两个不是一前一后相反方向还是查么？怎么他们两个返回的索引值相同呢？ because：lastIndexOf()方法虽然是从后往前搜索，但返回的位置是从前开始数数和计算的，所以结果和indexOf()方法返回的相同 总结： 当数组（字符串）中所要查询的数（字符串/字符）在字符串（数组）中只出现一次的时候 二者返回的索引值相同 当数组（字符串）中所要查询的数（字符串/字符）在字符串（数组）中出现两次及以上的时候 indexOf 返回的是 valuesearch 第一次在数组（字符串）出现的位置（从左往右） lastIndexOf 返回的是 valuesearch 最后一次在数组（字符串）出现的位置（从左往右）只不过查询的方向不同而已","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vue实现最多选择N个选项的方法","slug":"vue实现最多选择N个选项的方法","date":"2018-11-21T15:50:10.000Z","updated":"2018-11-21T15:53:39.905Z","comments":true,"path":"2018/11/21/vue实现最多选择N个选项的方法/","link":"","permalink":"http://yoursite.com/2018/11/21/vue实现最多选择N个选项的方法/","excerpt":"做这个需求被数组的问题困扰许久，之前想当然的把总的数据当成一个数组，选中的元素是一个数组，后面越整越复杂，把自己绕进去了。最后静下心来想一下，发现了个简洁的骚操作，就是在原来的数组基础上，循环为每一项加上selectedStatus属性，并且把选中的选项添加到一个数组中（obj.selectedArr）。这样无论以后是单选还是多选，只需传递不同的参数就能达到目的，此方法默认是多选","text":"做这个需求被数组的问题困扰许久，之前想当然的把总的数据当成一个数组，选中的元素是一个数组，后面越整越复杂，把自己绕进去了。最后静下心来想一下，发现了个简洁的骚操作，就是在原来的数组基础上，循环为每一项加上selectedStatus属性，并且把选中的选项添加到一个数组中（obj.selectedArr）。这样无论以后是单选还是多选，只需传递不同的参数就能达到目的，此方法默认是多选 1234567891011121314151617181920212223242526272829303132333435363738394041424344//item 对象//obj 对象数组//type默认传2代表多选，传1代表单选//max 默认传3代表最多选择3项，如果type参数传1，那max传什么都无所谓了selectedItem(item,obj,type=2，max=3)&#123; obj.map((ele,index)=&gt; &#123; if(!ele.selectedStatus)&#123; this.$set(ele,&apos;selectedStatus&apos;); ele.selectedStatus = false; &#125; &#125;); if(type==1)&#123; obj.map((ele,index) =&gt; &#123; ele.selectedStatus = false; &#125;); if(item.selectedStatus==false)&#123; obj.selectedItem=item; &#125;else&#123; obj.selectedItem=&apos;&apos;; &#125; &#125;else&#123; obj.map((ele,index) =&gt; &#123; ele.selectedStatus = ele.selectedStatus?ele.selectedStatus:false; &#125;); obj.selectedArr=obj.selectedArr?obj.selectedArr:new Array(); let index=obj.selectedArr.indexOf(item); if(obj.selectedArr.length==max)&#123; if(item.selectedStatus==false)&#123; obj.selectedArr[max-1].selectedStatus=false; obj.selectedArr[max-1]=item; &#125;else&#123; //obj.selectedArr[index].selectedStatus=false; obj.selectedArr.splice(index,1); &#125; &#125;else&#123; if(item.selectedStatus==false)&#123; obj.selectedArr.push(item); &#125;else&#123; obj.selectedArr.splice(index,1); &#125; &#125; &#125; item.selectedStatus =! item.selectedStatus; &#125;, obj实参示例：123456789101112131415161718192021222324252627282930[&#123;flag: &quot;https://oss.meiyi.ai/upload/image/201707/e9b4d059-b5a0-4e39-b3c3-5a41f5dbe232.jpg&quot;, id: 1,…&#125;flag: &quot;https://oss.meiyi.ai/upload/image/201707/e9b4d059-b5a0-4e39-b3c3-5a41f5dbe232.jpg&quot;id: 1name: &quot;美国&quot;value: 2&#125;,&#123;flag: &quot;https://oss.meiyi.ai/upload/image/201707/9de126a8-fbf7-4e97-ad4f-ad388bd9fdbc.jpg&quot;, id: 2,…&#125;flag: &quot;https://oss.meiyi.ai/upload/image/201707/9de126a8-fbf7-4e97-ad4f-ad388bd9fdbc.jpg&quot;id: 2name: &quot;加拿大&quot;value: 4&#125;,&#123;flag: &quot;https://oss.meiyi.ai/upload/image/201707/0e8ade2a-de71-4f0d-9ce5-b348a76e0598.jpg&quot;, id: 3,…&#125;flag: &quot;https://oss.meiyi.ai/upload/image/201707/0e8ade2a-de71-4f0d-9ce5-b348a76e0598.jpg&quot;id: 3name: &quot;澳大利亚&quot;value: 5&#125;,&#123;flag: &quot;https://oss.meiyi.ai/upload/image/201707/252884fe-ef95-49e2-99b1-a8220fc76679.jpg&quot;, id: 4,…&#125;flag: &quot;https://oss.meiyi.ai/upload/image/201707/252884fe-ef95-49e2-99b1-a8220fc76679.jpg&quot;id: 4name: &quot;新西兰&quot;value: 7&#125;,&#123;flag: &quot;https://oss.meiyi.ai/upload/image/201801/fc3adbf0-5f87-4608-aee3-38711b610a76.jpg&quot;, id: 5,…&#125;flag: &quot;https://oss.meiyi.ai/upload/image/201801/fc3adbf0-5f87-4608-aee3-38711b610a76.jpg&quot;id: 5name: &quot;西班牙&quot;value: 10&#125;] 使用方法： 单选：selectedItem（item,obj,1） 多选(最多选5项)：selectedItem（item,obj,2,5）;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"前端性能优化(上)","slug":"前端性能优化-上","date":"2018-10-27T05:00:59.000Z","updated":"2018-10-27T05:04:36.845Z","comments":true,"path":"2018/10/27/前端性能优化-上/","link":"","permalink":"http://yoursite.com/2018/10/27/前端性能优化-上/","excerpt":"网络方面的优化我们往往在一张图片满足以下条件时会对它应用 Base64 编码： 图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的） 图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）heh 图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低） webP WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。 WebP 纵有千般好，但它毕竟太年轻。我们知道，任何新生事物，都逃不开兼容性的大坑。兼容性现在还是不怎么友好，只有chrome（亲爹）兼容比较齐全。 Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接： 1&lt;img src=&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg&quot; alt=&quot;手机app - 聚划算&quot; class=&quot;app-icon&quot;&gt; 我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。 此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 ==Accept== 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。","text":"网络方面的优化我们往往在一张图片满足以下条件时会对它应用 Base64 编码： 图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的） 图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）heh 图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低） webP WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。 WebP 纵有千般好，但它毕竟太年轻。我们知道，任何新生事物，都逃不开兼容性的大坑。兼容性现在还是不怎么友好，只有chrome（亲爹）兼容比较齐全。 Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接： 1&lt;img src=&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg&quot; alt=&quot;手机app - 聚划算&quot; class=&quot;app-icon&quot;&gt; 我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。 此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 ==Accept== 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。 存储方面的优化 cookie localStorage sessionStorage IndexDB Local Storage 与 Session Storage 的区别两者的区别在于生命周期与作用域的不同。 生命周期：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。 作用域：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。 Web Storage 的特性 存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。 仅位于浏览器端，不与服务端发生通信。 应用场景 Local Storage Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。 这里给大家举个例子，考虑到 Local Storage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串。有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。 Session Storage Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹。 终极形态：IndexDBIndexDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。 应用场景通过上面的示例大家可以看出，在 IndexDB 中，我们可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。IndexDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，我们毫无疑问可以请出 IndexDB 来帮忙。","categories":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/categories/前端优化/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/tags/前端优化/"}]},{"title":"主流浏览器图片反防盗链方法总结","slug":"主流浏览器图片反防盗链方法总结","date":"2018-10-19T14:54:33.000Z","updated":"2018-10-19T16:02:19.841Z","comments":true,"path":"2018/10/19/主流浏览器图片反防盗链方法总结/","link":"","permalink":"http://yoursite.com/2018/10/19/主流浏览器图片反防盗链方法总结/","excerpt":"前言还记得之前写的那个无聊的插件，前一段时间由于豆瓣读书增加了防盗链策略使得我们无法直接引用他们的图片，使得我这个小插件无法工作。本以为是一个很简单的问题，但是没想到这个小问题硬是让我改了五六遍才改好，可以说是非常的蠢了。总结一下自己犯傻的原因，还是由于自己懒得去深入研究，谷歌百度了问题就直接把方案拿来用了，浅尝辄止人云亦云，解决了表面的问题而没有深入的总结。当然，从另外一个方面讲，我也是初步领会到了前端程序员面对要兼容各种浏览器的需求时头有多大了。 问题问题很简单，就是我希望在自己的页面里用来引用其他网站的一张图片，但是他的网站设置了防盗链的策略，会在后台判断请求的Referrer属性是不是来自于一个非本域名的网站，如果来源不是本域名就返回403 forbidden。我的目的就是用最方便的方法使得我的页面能够不受他的防盗链策略的影响。","text":"前言还记得之前写的那个无聊的插件，前一段时间由于豆瓣读书增加了防盗链策略使得我们无法直接引用他们的图片，使得我这个小插件无法工作。本以为是一个很简单的问题，但是没想到这个小问题硬是让我改了五六遍才改好，可以说是非常的蠢了。总结一下自己犯傻的原因，还是由于自己懒得去深入研究，谷歌百度了问题就直接把方案拿来用了，浅尝辄止人云亦云，解决了表面的问题而没有深入的总结。当然，从另外一个方面讲，我也是初步领会到了前端程序员面对要兼容各种浏览器的需求时头有多大了。 问题问题很简单，就是我希望在自己的页面里用来引用其他网站的一张图片，但是他的网站设置了防盗链的策略，会在后台判断请求的Referrer属性是不是来自于一个非本域名的网站，如果来源不是本域名就返回403 forbidden。我的目的就是用最方便的方法使得我的页面能够不受他的防盗链策略的影响。 解决方案1、后台预下载预下载是最直观的一种方法，既然不能直接引用，那我就先后台下载下来，然后将图片链接到下载后的图片即可。这个方法还是比较稳妥的，图片下载下来就是自己的了，不会再受人限制。不过这总有种侵犯知识产权的感觉，而且每张图片都要后台先下载，逻辑处理起来还是有点麻烦的；而且对于那种纯静态页面，没有后台程序供我们发挥，这也就无法实现了。 2、第三方代理第三方代理其实算是后台与下载的升级版，其实就是将下载图片的这个过程交给第三方的网站。一个非常好用的代理是images.weserv.nl，我们可以直接将自己需要“盗链”的图片写在请求中即可。我们甚至可以指定一些简单的图片处理参数，让代理帮我们处理。 比如我想盗链https://foo.com/foo.jpg，并且将图片宽度设置成100，我们就可以直接这样引用: 1&lt;img src=&quot;https://images.weserv.nl/?url=foo.com/foo.jpg&amp;w=100&quot; /&gt; 这还是很方便的，不过美中不足的是这个国外的网站在国内的访问速度似乎有点慢，有时候甚至还会被墙，这就有点尴尬了。 3、删除Header中的Referrer相比上面两种折腾的方法，如果能直接修改Referrer，那不就省了很多事了么。但是事实上这里的配置还是有挺多坑的，方法也有很多种，一不小心就会跟我一样踩了一遍又一遍。 添加meta标签一种方法是给页面添加一个meta标签，在meta标签里指定referrer的值，比如。网上可以查到各种奇奇怪怪的值，其实我总结了来源于两个地方。 一个是来自whatwg的标准。他给meta标签的referrer属性定义了四个值：never,always,origin,default。如果需要关闭referrer，就将referrer的值设置成”never”。这个标准还是比较老的，而且在他的主页上也明确写了”This document is obsolete.”。不过据我调研，或许正是由于这个标准比较老，反而导致绝大多数浏览器对他的支持都很好，因祸得福蛤蛤。 另外一个是来自MDN的标准。他给meta标签的referrer属性定义了五个值，如果要关闭referrer，就将它的值设置成no-referrer。 不过我们需要注意的是，meta标签添加的位置也很重要，有的浏览器能够识别非head标签中的meta标签，有的就不行。在实际使用的时候还要小心，这一点下文会有一个更具体的比较。 添加ReferrerPolicy属性添加meta标签相当于对文档中的所有链接都取消了referrer，而ReferrerPolicy则更精确的指定了某一个资源的referrer策略。关于这个策略的定义可以参照MDN。比如我想只对某一个图片取消referrer，如下编写即可: 浏览器支持对比上面我们讲了两种取消referrer头信息的方法，但其实这却对应了五种写法，我们来看下面的对比表： 可以看出Chrome浏览器对各种写法都支持的最好，棒棒哒；Firefox支持所有标准的写法，但是不支持没有写在head标签中的meta标签；Edge/IE则不支持MDN里定义的”no-referrer”配置项，果然是个古董。。。 总的来说，保证最佳效果的最简单的写法就是添加一个meta标签，这样就不用考虑浏览器的差别了，虽然这种写法并不被官方推荐(主要还是要迁就IE这个古董，放弃了理论上更为正确的标准)。","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://yoursite.com/categories/前端安全/"}],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"http://yoursite.com/tags/前端安全/"}]},{"title":"module替代scopet","slug":"module替代scopet","date":"2018-10-11T12:27:49.000Z","updated":"2018-10-11T12:30:05.320Z","comments":true,"path":"2018/10/11/module替代scopet/","link":"","permalink":"http://yoursite.com/2018/10/11/module替代scopet/","excerpt":"关于CSS Modulecss modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。vue引入scopet，有缺陷的样式私有化 最开始的时候，我们提倡并大量使用的是scoped这种技术在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。","text":"关于CSS Modulecss modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。vue引入scopet，有缺陷的样式私有化 最开始的时候，我们提倡并大量使用的是scoped这种技术在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。 12345@media (min-width: 250px) &#123;.list-container:hover &#123;background: orange;&#125;&#125; 这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover 但是，它并不能完全避免冲突如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示并且它会造成一种后果，每个样式的权重加重了：理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。这是增加复杂度的其中一个维度。 CSS modules则做的更好，它不是添加属性，而是直接改变类名 SS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。 类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？ CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等…… CSS模块化就是来解决这个问题的，一般地，分为三类 命名约定类 该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章 CSS in JS 彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components 使用JS来管理样式 使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules 随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可 VUE的CSS Module写法 使用时需要进行添加v-bind，如样式绑定简写 :class-① 在style标签中添加module属性，表示打开CSS-loader的模块模式 123&lt;style module&gt;.red &#123;color: red;&#125;&lt;/style&gt; ② 在模板中使用动态类绑定 :class ，并在类名前面加上 $style. 12345&lt;template&gt; &lt;p :class=&quot;$style.red&quot;&gt; This should be red &lt;/p&gt;&lt;/template&gt; ③ 如果类名包含中划线，则使用中括号语法 1&lt;h4 :class=&quot;$style[&apos;header-tit&apos;]&quot;&gt;类别推荐&lt;/h4&gt; ④ 也可以使用数组或对象语法 123456&lt;p :class=&quot;&#123; [$style.red]: isRed &#125;&quot;&gt; Am I red?&lt;/p&gt;&lt;p :class=&quot;[$style.red, $style.bold]&quot;&gt; Red and bold&lt;/p&gt; ⑤ 更复杂的对象语法 12345&lt;ul :class=&quot;&#123; [$style.panelBox]:true, [$style.transitionByPanelBox]:needTransition &#125;&quot; ⑥ 更复杂的数组语法 12345&lt;li :class=&quot;[ $style[&apos;aside-item&apos;], &#123;[$style[&apos;aside-item_active&apos;]]:(i === index)&#125; ]&quot; 配置 css-loader关于CSS modules的默认配置如下 12345&#123; modules: true, importLoaders: 1, localIdentName: &apos;[hash:base64]&apos;&#125; 可以使用vue-loader的cssModules选项为css-loader进行自定义的配置 1234567891011121314module: &#123; rules: [ &#123; test: &apos;\\.vue$&apos;, loader: &apos;vue-loader&apos;, options: &#123; cssModules: &#123; localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;, camelCase: true &#125; &#125; &#125; ]&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"css","slug":"vue/css","permalink":"http://yoursite.com/categories/vue/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"documentFragment对象","slug":"documentFragment对象","date":"2018-10-10T12:51:05.000Z","updated":"2018-10-10T12:51:37.562Z","comments":true,"path":"2018/10/10/documentFragment对象/","link":"","permalink":"http://yoursite.com/2018/10/10/documentFragment对象/","excerpt":"","text":"一般动态创建html元素都是创建好了直接appendChild()上去，但是如果要添加大量的元素还用这个方法的话就会导致大量的重绘以及回流，所以需要一个’缓存区’来保存创建的节点，然后再一次性添加到父节点中。这时候DocumentFragment对象就派上用场了。 看下w3c的官方说明：DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。 不过它有一种特殊的行为，该行为使得它非常有用，即当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。 重点就在于DocumentFragment 节点不属于文档树。因此当把创建的节点添加到该对象时，并不会导致页面的回流，因此性能就自然上去了。 创建该对象也简单：1234567891011121314151617var fragment = document.createDocumentFragment();看下实例：复制代码&lt;script type=&quot;text/javascript&quot;&gt; var pNode,fragment = document.createDocumentFragment(); for(var i=0; i&lt;20; i++)&#123; pNode = document.createElement(&apos;p&apos;); pNode.innerHTML = i; fragment.appendChild(pNode); &#125; document.body.appendChild(fragment);&lt;/script&gt;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"在vue中使用SockJS实现webSocket长连接通信的过程","slug":"在vue中使用SockJS实现webSocket长连接通信的过程","date":"2018-10-09T12:46:03.000Z","updated":"2018-10-09T12:47:51.992Z","comments":true,"path":"2018/10/09/在vue中使用SockJS实现webSocket长连接通信的过程/","link":"","permalink":"http://yoursite.com/2018/10/09/在vue中使用SockJS实现webSocket长连接通信的过程/","excerpt":"最近一个业务需求，需要和服务器端建立webSocket连接,从而实现消息的实时推送 socksjs 客户端和服务器端api尽可能简洁，尽量靠近websocket api 支持服务端扩展和负载均衡技术 传输层应该全面支持跨域通信 如果受到代理服务器的限制，传输层能优雅地从一种方式回退到另一种方式 尽可能快地建立连接 客户端只是纯粹的JavaScript，不需要flash 客户端JavaScript必须经过严格的测试 服务器端代码尽可能简单，降低用另一种语言重写server的代价","text":"最近一个业务需求，需要和服务器端建立webSocket连接,从而实现消息的实时推送 socksjs 客户端和服务器端api尽可能简洁，尽量靠近websocket api 支持服务端扩展和负载均衡技术 传输层应该全面支持跨域通信 如果受到代理服务器的限制，传输层能优雅地从一种方式回退到另一种方式 尽可能快地建立连接 客户端只是纯粹的JavaScript，不需要flash 客户端JavaScript必须经过严格的测试 服务器端代码尽可能简单，降低用另一种语言重写server的代价 前提 要进行文章中的代码的测试,需要服务端端开发人员配合你,提供相关的通信接口.来完成客户端和服务端的通信.实现通信,我们需要用到另个模块 sockjs-client 模块和 stomjs 模块,接下来我会先对这两个模块做一个简单的介绍. 关于实时通信 ajax轮询 ajax轮询的原理非常简单,让浏览器每隔几秒就像服务器发送一个请求,询问服务器是否有新的信息. http 长轮询 长轮询的机制和ajax轮询差不多,都是采用轮询的方式,不过才去的是阻塞模型(一直打电话,没收到就不挂电话),也就是说,客户端发起链接后,如果没有消息,就一直不返回response给客户端.知道有新的消息才返回,返回完之后,客户端再此建立连接,周而复始. WebSocket WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议.在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送,不需要繁琐的询问和等待. 从上面的介绍很容易看出来,ajax轮询和长轮询都是非常耗费资源的,ajax轮询需要服务器有很快的处理速度和资源,http长轮询需要有很高的并发,也就是同时接待客户的能力.而WebSocket,只需要经过一次HTTP请求,就可以与服务端进行源源不断的消息收发了. sockjs-clientsockjs-client 是从SockJS中分离出来的用于客户端使用的通信模块.所以我们就直接来看看SockJS. SockJS是一个浏览器的JavaScript库,它提供了一个类似于网络的对象,SockJS提供了一个连贯的,跨浏览器的JavaScriptAPI,它在浏览器和Web服务器之间创建了一个低延迟,全双工,跨域通信通道. 你可能会问,我为什么不直接用原生的WebSocket而要使用SockJS呢?这得益于SockJS的一大特性,一些浏览器中缺少对WebSocket的支持,因此，回退选项是必要的，而Spring框架提供了基于SockJS协议的透明的回退选项。SockJS提供了浏览器兼容性,优先使用原生的WebSocket,如果某个浏览器不支持WebSocket,SockJS会自动降级为轮询. stomjsSTOMP(Simple Text-Orientated Messaging Protocol) 面向消息的简单文本协议; WebSocket是一个消息架构,不强制使用任何特定的消息协议,它依赖于应用层解释消息的含义. 与HTTP不同,WebSocket是处在TCP上非常薄的一层,会将字节流转化为文本/二进制消息,因此,对于实际应用来说,WebSocket的通信形式层级过低,因此，可以在 WebSocket 之上使用STOMP协议，来为浏览器 和 server间的 通信增加适当的消息语义。 STOMP与WebSocket 的关系: HTTP协议解决了web浏览器发起请求以及web服务器响应请求的细节,假设HTTP协议不存在,只能使用TCP套接字来编写web应用,你可能认为这是一件疯狂的事情; 直接使用WebSocket(SockJS)就很类似于使用TCP套接字来编写web应用,因为没有高层协议,就需要我们定义应用间发送消息的语义,还需要确保连接的两端都能遵循这些语义; 同HTTP在TCP套接字上添加请求-响应模型层一样,STOMP在WebSocket之上提供了一个基于帧的线路格式层,用来定义消息语义.- 代码实现 代码中除了最基本的连接,还设置了一个定时器,每隔十秒发送一条数据到服务器端,如果发生错误,catch这个错误,重新建立连接. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 安装并引入相关模块import SockJS from &apos;sockjs-client&apos;;import Stomp from &apos;stompjs&apos;;export default &#123; data() &#123; return &#123; dataList: [] &#125;; &#125;, mounted:function()&#123; this.initWebSocket(); &#125;, beforeDestroy: function () &#123; // 页面离开时断开连接,清除定时器 this.disconnect(); clearInterval(this.timer); &#125;, methods: &#123; initWebSocket() &#123; this.connection(); let self = this; // 断开重连机制,尝试发送消息,捕获异常发生时重连 this.timer = setInterval(() =&gt; &#123; try &#123; self.stompClient.send(&quot;test&quot;); &#125; catch (err) &#123; console.log(&quot;断线了: &quot; + err); self.connection(); &#125; &#125;, 5000); &#125;, removeTab(targetName) &#123; console.log(targetName) &#125;, connection() &#123; // 建立连接对象 this.socket = new SockJS(&apos;http://xxxxxx:8089/ws&apos;);//连接服务端提供的通信接口，连接以后才可以订阅广播消息和个人消息 // 获取STOMP子协议的客户端对象 this.stompClient = Stomp.over(this.socket); // 定义客户端的认证信息,按需求配置 var headers = &#123; login: &apos;mylogin&apos;, passcode: &apos;mypasscode&apos;, // additional header &apos;client-id&apos;: &apos;my-client-id&apos; &#125;; // 向服务器发起websocket连接 this.stompClient.connect(headers,(frame) =&gt; &#123; this.stompClient.subscribe(&apos;/topic/chat_msg&apos;, (msg) =&gt; &#123; // 订阅服务端提供的某个topic consolel.log(msg.body); // msg.body存放的是服务端发送给我们的信息 &#125;); &#125;, (err) =&gt; &#123; &#125;); &#125;, disconnect() &#123; if (this.stompClient != null) &#123; this.stompClient.disconnect(); console.log(&quot;Disconnected&quot;); &#125; &#125; &#125;&#125;; 总结：websocket的实现有很多种，不过这个插件相对兼容性大些。以上就是vue中使用SockJS实现webSocket通信的过程，希望对大家有帮助。","categories":[{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"},{"name":"sockJs","slug":"sockJs","permalink":"http://yoursite.com/tags/sockJs/"}]},{"title":"vue中slot的使用","slug":"vue中slot的使用","date":"2018-10-08T12:14:44.000Z","updated":"2018-10-08T12:27:22.556Z","comments":true,"path":"2018/10/08/vue中slot的使用/","link":"","permalink":"http://yoursite.com/2018/10/08/vue中slot的使用/","excerpt":"将父组件的内容放到子组件指定的位置叫做内容分发1234//在父组件里使用子组件&lt;son-tmp&gt; &lt;div&gt;我是文字，我需要放到son-tmp组件里面制定的位置&lt;/div&gt;&lt;/son-tmp&gt;","text":"将父组件的内容放到子组件指定的位置叫做内容分发1234//在父组件里使用子组件&lt;son-tmp&gt; &lt;div&gt;我是文字，我需要放到son-tmp组件里面制定的位置&lt;/div&gt;&lt;/son-tmp&gt; 单个插槽 父组件app.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;test-slot&gt; &lt;span&gt;我是父组件里的文字，但是我要被放到子组件里&lt;/span&gt; &lt;/test-slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import testSlot from &apos;./components/testSlot&apos;export default &#123; data()&#123; return &#123; &#125; &#125;, components:&#123; testSlot &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件testSlot.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h3&gt;test-slot&lt;/h3&gt; //父组件里的span会替换掉slot所以这里的123是看不见的 //如果父组件在使用子组件testSlot的时候不在里面加内容则这里的slot会显示出来 &lt;slot&gt;123&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 效果图： 多个插槽也叫具名插槽 具名插槽就是将某个名字的内容插到子组件对应名字里面去父组件app.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div id=&quot;app&quot;&gt; //使用子组件testSlot &lt;test-slot&gt; //slot=one这个div会替换掉子组件里name=&quot;one&quot;的slot标签 &lt;div slot=&quot;one&quot;&gt; &lt;span&gt;one&lt;/span&gt; &lt;span&gt;第一个&lt;/span&gt; &lt;/div&gt; //这个div没有用slot指定名字所以会替换掉子组件里没有name属性的slot标签 &lt;div&gt; &lt;span&gt;此div没有slot&lt;/span&gt; &lt;/div&gt; //slot=two这个div会替换掉子组件里name=&quot;two&quot;的slot标签 &lt;div slot=&quot;two&quot;&gt; &lt;span&gt;two&lt;/span&gt; &lt;span&gt;第二个&lt;/span&gt; &lt;/div&gt; &lt;/test-slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import testSlot from &apos;./components/testSlot&apos;export default &#123; data()&#123; return &#123; &#125; &#125;, components:&#123; testSlot &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件testSlot.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;testSlot&quot;&gt; &lt;div class=&quot;noneSlot&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;test-two&quot;&gt; &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;test-one&quot;&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 作用域插槽（将子组件的值传到父组件供使用） 父组件app.vue 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;app&lt;/h2&gt; &lt;test-slot :items=&quot;items&quot;&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;span&gt;&#123;&#123; props.addr &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; props.cname &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; props.age &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/test-slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import testSlot from &apos;./components/testSlot.vue&apos;export default &#123; data ()&#123; return &#123; items:[ &#123; text:&apos;文字1&apos; , cname:&apos;tom&apos; , addr:&apos;usa&apos; &#125;, &#123; text:&apos;文字2&apos; , cname:&apos;wangwu&apos; , addr:&apos;uk&apos; &#125;, &#123; text:&apos;文字3&apos; , cname:&apos;zhangsan&apos; , addr:&apos;un&apos; &#125; ] &#125; &#125;, methods:&#123; &#125;, components:&#123; testSlot &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件testSlot.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;slot :cname=&quot;items[2].cname&quot;&gt;&lt;/slot&gt; &lt;slot :addr=&quot;items[2].addr&quot;&gt;&lt;/slot&gt; &lt;slot age=&quot;18&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; num:100 &#125; &#125;, props:[&apos;items&apos;], methods:&#123; &#125;, created()&#123; console.log(&apos;items&apos;,this.$props.items); &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 效果图： 如何理解Vue的作用域插槽 举个例子，比如我写了一个可以实现条纹相间的列表组件，发布后，使用者可以自定义每一行的内容或样式（普通的slot就可以完成这个工作）。而作用域插槽的关键之处就在于，父组件能接收来自子组件的slot传递过来的参数，具体看案例和注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue作用域插槽&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.3.4/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app2&quot;&gt; &lt;!-- 组件使用者只需传递users数据即可 --&gt; &lt;my-stripe-list :items=&quot;users&quot; odd-bgcolor=&quot;#D3DCE6&quot; even-bgcolor=&quot;#E5E9F2&quot;&gt; &lt;!-- props对象接收来自子组件slot的$index参数 --&gt; &lt;template slot=&quot;cont&quot; scope=&quot;props&quot;&gt; &lt;span&gt;&#123;&#123;users[props.$index].id&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;users[props.$index].name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;users[props.$index].age&#125;&#125;&lt;/span&gt; &lt;!-- 这里可以自定[编辑][删除]按钮的链接和样式 --&gt; &lt;a :href=&quot;&apos;#edit/id/&apos;+users[props.$index].id&quot;&gt;编辑&lt;/a&gt; &lt;a :href=&quot;&apos;#del/id/&apos;+users[props.$index].id&quot;&gt;删除&lt;/a&gt; &lt;/template&gt; &lt;/my-stripe-list&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;my-stripe-list&apos;, &#123; /*slot的$index可以传递到父组件中*/ template: ` &lt;div&gt; &lt;div v-for=&quot;(item, index) in items&quot; style=&quot;line-height:2.2;&quot; :style=&quot;index % 2 === 0 ? &apos;background:&apos;+oddBgcolor : &apos;background:&apos;+evenBgcolor&quot;&gt; &lt;slot name=&quot;cont&quot; :$index=&quot;index&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `, props: &#123; items: Array, oddBgcolor: String, evenBgcolor: String &#125; &#125;); new Vue(&#123; el: &apos;#app2&apos;, data: &#123; users: [ &#123;id: 1, name: &apos;张三&apos;, age: 20&#125;, &#123;id: 2, name: &apos;李四&apos;, age: 22&#125;, &#123;id: 3, name: &apos;王五&apos;, age: 27&#125;, &#123;id: 4, name: &apos;张龙&apos;, age: 27&#125;, &#123;id: 5, name: &apos;赵虎&apos;, age: 27&#125; ] &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"css编码规范","slug":"css编码规范","date":"2018-10-07T15:31:31.000Z","updated":"2018-10-07T15:40:56.527Z","comments":true,"path":"2018/10/07/css编码规范/","link":"","permalink":"http://yoursite.com/2018/10/07/css编码规范/","excerpt":"页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary","text":"页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright 1234567891011121314151617181920212223242526272829303132333435363738391. 内容优先,表现为辅 2. css命名中英文对照 current 当前 hover 悬停 selected 挑选 disabled 禁用 focus 得到焦点 blur 失去焦点 checked 勾选 success 成功 error 出错 header(hd) 头部 content(cnt) 内容 title(tit) 标题 item 项目（条） cell 单元 image/pic(img) 图片 text(txt) 文字 top 顶部 scrubber 时序菜单 nav 导航 mainbav 主导航 subnav 子导航 topnav 顶部导航 breadcrumb 面包屑导航 flink 友情链接 footer 尾 copyright 版权 menu 菜单 submenu 子菜单 dropdown 下拉菜单 searchBar 搜索条 search 搜索条 searchTxt 搜索框 searchBtn 搜索按钮 search_key 搜索词 member 会员 ucenter 用户中心 loginBar 登陆条 login 登录 loginBtn 登录按钮 regsiter 注册按钮 btn-regsiter注册按钮 name 用户名 password 密码 nickname 昵称 mobilephone/mobile 手机 telephone/tel 电话 defaultavatar 默认头像 hot 热点 news 新闻 banner/AD 广告 download 下载 content 内容 title 标题 summary 摘要 time 时间 share 分享 digg 顶 like 喜欢 list 列表 pList 图片列表 tList 文字列表 tpList 图文列表 table 表格 row 行 column 列 gutter 间隔 viewport 视口 tab 标签 tags 标签 scroll 滚动 sidebar 侧边栏 column 栏目 section 区块 msg 提示信息 status 状态 vote 投票 tips 小技巧 guild 指南 note 注释 icon- 图标 btn- 按钮 goods 商品 goodsList 商品列表 goodsDetail 商品详情 goodsInfo 商品信息 tuan 团购 tuanList 团购列表 tuanDetail 团购详情 tuanInfo 团购信息 transition 动画 shadow 阴影 fade 淡入淡出 flip 翻页效 slide 滑动 slideup 上滑动 slidedown 下滑动 turn 翻页 horizontal 水平 vertical 垂直 collapsible 折叠 corners 拐角 flow 流 reverse 反向 pop 弹窗 count 总数/计数 plus 加号/正 minus 减号/负 controlgroup 控制组 样式文件命名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 主要的:master.css 布局版面:layout.css 专栏:columns.css 文字:font.css 打印样式:print.css 主题:themes.css说明：均为class，需要扩展，则在当前命名内以“_“(下划线)后缀自定名称。我习惯称列表页为list，新闻列表则为newslist，图片列表为piclist，内容页为view，/**/整体大框架：#wrapper大框架内：#inwrapper/////////////////////////////////////////////////////////////////////////////////////////////////////////顶部及banner：.top顶部及banner内：.intopLogo：.logoBanner：.banner导航：.menu导航内：.inmenu .Menuul .Menuul li .Menuul li a下拉菜单：.inmenu_xiala .Inmenu_xialaul .Inmenu_xialaul li .Inmenu_xialaul li a///////////////////////////////////////////////////////////////////////////////////////////////////////////主体内容：.mainWrapper主体内容内：.inmainwrapper左侧拦：.sideleft左侧内：.insideleft右侧栏：.sideright右侧内：.insideright中间：.sidecenter中间内：.insidecenter/////////////////////////////////////////////////////////////////////////////////////////////////////////////底部：.foot底部内：.infoot/////////////////////////////////////////////////////////////////////////////////////////////////////////////*其他命名*/搜索：.search搜索内：.insearch搜索条：.searchselect搜索按钮：.serachbuttom输入文本框：.input.select/*表格样式*/表格整体框架：.listbox表格的宽度：.listbox-table表格头部文字样式：.listbox-header表格正文文字样式：.listbox-entry/*通用型*/通用：.GM/*这个有点郁闷,英文太差...*/通用内：.INGM通用左浮动：.GMfl(GM FLOAT LEFT)通用右浮动：.GMfr(GM FLOAT RIGHT)/*通用图片样式*/通用图片样式：.img/*清除浮动*/清除所有浮动：.clear清除左侧浮动：.clearleft清除右侧浮动：.clearright/*文字样式*/文字：.font/*新闻列表*/新闻列表：.fontnews/*View页字体总样式*/VIEW页字体：.fontview","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"常用JS函数，方法举例","slug":"常用js","date":"2018-09-30T14:33:31.000Z","updated":"2018-10-07T15:41:06.477Z","comments":true,"path":"2018/09/30/常用js/","link":"","permalink":"http://yoursite.com/2018/09/30/常用js/","excerpt":"1. push()与unshift()方法 把一个或多个元素添加到数组的尾部，请使用 push() 方法 往数组头部添加元素，用unshift（）方法 2. split(‘.’)[1] 这里split(‘.’)[1] 是一种缩写形式，把它拆开来看实际就是先用split(‘.’)方法将字符串以”.”开割形成一个字符串数组，然后再通过索引[1]取出所得数组中的第二个元素的值 3. findIndex() findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 4. substr() substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。在本例中，我们将使用 substr() 从字符串中提取一些字符： 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.substr(3,7))&lt;/script&gt;输出：lo worl","text":"1. push()与unshift()方法 把一个或多个元素添加到数组的尾部，请使用 push() 方法 往数组头部添加元素，用unshift（）方法 2. split(‘.’)[1] 这里split(‘.’)[1] 是一种缩写形式，把它拆开来看实际就是先用split(‘.’)方法将字符串以”.”开割形成一个字符串数组，然后再通过索引[1]取出所得数组中的第二个元素的值 3. findIndex() findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 4. substr() substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。在本例中，我们将使用 substr() 从字符串中提取一些字符： 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.substr(3,7))&lt;/script&gt;输出：lo worl 5. js验证手机格式123456789101112/** * @param str 对应手机号码 * @returns &#123;boolean&#125; 结果返回 true 和 false。 * true 为正确手机号码 * false 为错误手机号码 */function verifyPhoneNumberFormat(str)&#123; var myreg = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; return myreg.test(str);&#125;调用方法：verifyPhoneNumberFormat(&quot;18818592555&quot;); 6. JS验证身份证格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 * 地址码表示编码对象常住户口所在县(市、旗、区)的行政区划代码。 * 出生日期码表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。 * 顺序码表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。 * 校验码是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。 * 出生日期计算方法。 * 15位的身份证编码首先把出生年扩展为4位，简单的就是增加一个19或18,这样就包含了所有1800-1999年出生的人; * 2000年后出生的肯定都是18位的了没有这个烦恼，至于1800年前出生的,那啥那时应该还没身份证号这个东东，⊙﹏⊙b汗... * 下面是正则表达式: * 出生日期1800-2099 (18|19|20)?\\d&#123;2&#125;(0[1-9]|1[12])(0[1-9]|[12]\\d|3[01]) * 身份证正则表达式 /^\\d&#123;6&#125;(18|19|20)?\\d&#123;2&#125;(0[1-9]|1[12])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;(\\d|X)$/i * 15位校验规则 6位地址编码+6位出生日期+3位顺序号 * 18位校验规则 6位地址编码+8位出生日期+3位顺序号+1位校验位 * 校验位规则 公式:∑(ai×Wi)(mod 11)……………………………………(1) * 公式(1)中： * i----表示号码字符从由至左包括校验码在内的位置序号； * ai----表示第i位置上的号码字符值； * Wi----示第i位置上的加权因子，其数值依据公式Wi=2^(n-1）(mod 11)计算得出。 * i 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 * Wi 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 1 * ============================================================================================ * 身份证号合法性验证 * 支持15位和18位身份证号 * 支持地址编码、出生日期、校验位验证 * @param code * @returns &#123;*[]&#125; 该函数返回一个数组 [true,&apos;&apos;] 或 [false,&quot;身份证号格式错误&quot;] * @constructor */function IdentityCodeValid(code) &#123; var city=&#123;11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江 &quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北 &quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏 &quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外 &quot;&#125;; var tip = &quot;&quot;; var pass= true; if(!code || !/^\\d&#123;6&#125;(18|19|20)?\\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;(\\d|[xX])$/i.test(code))&#123; tip = &quot;身份证号格式错误&quot;; pass = false; &#125; else if(!city[code.substr(0,2)])&#123; tip = &quot;地址编码错误&quot;; pass = false; &#125; else&#123; //18位身份证需要验证最后一位校验位 if(code.length == 18)&#123; code = code.split(&apos;&apos;); //∑(ai×Wi)(mod 11) //加权因子 var factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ]; //校验位 var parity = [ 1, 0, &apos;X&apos;, 9, 8, 7, 6, 5, 4, 3, 2 ]; var sum = 0; var ai = 0; var wi = 0; for (var i = 0; i &lt; 17; i++) &#123; ai = code[i]; wi = factor[i]; sum += ai * wi; &#125; var last = parity[sum % 11]; if(parity[sum % 11] != code[17])&#123; tip = &quot;校验位错误,结尾是字母请注意大小写&quot;; pass =false; &#125; &#125; &#125; // if(!pass) alert(tip); //return pass; return [pass,tip]&#125;调用方法：IdentityCodeValid(&quot;110000198304102033&quot;); 7. JS判断两个数组是否相等123456789101112131415161718/** * JS判断两个数组是否相等 * @param &#123;Array&#125; arr1 * @param &#123;Array&#125; arr2 * @returns &#123;boolean&#125; 返回true 或 false */function arrayEqual(arr1, arr2) &#123; if (arr1 === arr2) return true; if (arr1.length != arr2.length) return false; for (var i = 0; i &lt; arr1.length; ++i) &#123; if (arr1[i] !== arr2[i]) return false; &#125; return true;&#125;调用方法：var arr1 = [&apos;a&apos;,&apos;b&apos;];var arr2 = [&apos;a&apos;,&apos;b&apos;];arrayEqual(arr1,arr2); 8. JS格式化金额xxx,xxx,xxx1234567891011121314151617181920212223242526272829/** * JS格式化金额 * @param money * @param type * @returns &#123;*&#125; */function convert(money , type) &#123; if (/[^0-9\\.]/.test(money)) return &quot;0&quot;; if (money == null || money == &quot;&quot;) return &quot;0&quot;; money = money.toString().replace(/^(\\d*)$/, &quot;$1.&quot;); money = (money + &quot;00&quot;).replace(/(\\d*\\.\\d\\d)\\d*/, &quot;$1&quot;); money = money.replace(&quot;.&quot;, &quot;,&quot;); var re = /(\\d)(\\d&#123;3&#125;,)/; while (re.test(money)) money = money.replace(re, &quot;$1,$2&quot;); money = money.replace(/,(\\d\\d)$/, &quot;.$1&quot;); if (type == 0) &#123;// 不带小数位(默认是有小数位) var a = money.split(&quot;.&quot;); if (a[1] == &quot;00&quot;) &#123; money = a[0]; &#125; &#125; return money;&#125;调用方法：convert(311546161685); // 311,546,161,685.00convert(311546161685,0); // 311,546,161,685 9. JS数组去重12345678910111213141516171819/** * JS数组去重 * @param arr 数组 * @returns &#123;Array&#125; 结果返回数组 */function removeReapt(arrs)&#123; var arr= []; var json = &#123;&#125;; for(var i = 0,len = arrs.length; i &lt; len; i++)&#123; if(!json[arrs[i]])&#123; arr.push(arrs[i]); json[arrs[i]] = 1; &#125; &#125; return arr;&#125;调用方法：var arr = [11,22,33,46,79,11,46,97,79,46];removeReapt(arr); 10. JS数组冒泡排序12345678910111213141516171819202122/** * 冒泡排序 * @param array 数组 * @returns &#123;*&#125; */function maoPaoSort(array)&#123; var temp; for(var i=0;i&lt;array.length;i++)&#123; //比较多少趟，从第一趟开始 for(var j=0;j&lt;array.length-i-1;j++)&#123; //每一趟比较多少次数 if(array[j]&gt;array[j+1])&#123; temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125; return array;&#125;调用方法：var arrry=[85,24,63,17,31,17,86,50];console.log(maoPaoSort(arrry)); 11. JS判断是否以某个字符串开头123456789101112/** * 判断是否以某个字符串开头 * @param str 字符串 * @param s 以哪个字符串开头 * @returns &#123;boolean&#125; 返回true为正确，false为错误 */function startWith(str,s)&#123; return str.indexOf(s) == 0;&#125;调用方法：var test = &quot;sdasd sdx adsad asd sa &quot;;console.log(startWith(test,&quot;a&quot;)); // 例如：false 12. JS判断是否以某个字符串结束12345678910111213/** * 判断是否以某个字符串结束 * @param str 总字符串 * @param s 某个字符串 * @returns &#123;boolean&#125; */function endWith(str,s)&#123; var d = str.length - s.length; return (d &gt;= 0 &amp;&amp; str.lastIndexOf(s) == d);&#125;调用方法：var test = &quot;sdasd sdx adsad asd sa&quot;;console.log(endWith(test,&quot;a&quot;)); // 例如:true 13. JS判断是否为数字类型123456789101112131415161718/** * 判断是否为数字类型 * @param value 判断的值 * @returns &#123;boolean&#125; */function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == &quot;&quot;) &#123; return false &#125; else &#123; return true &#125;&#125;调用方法：var test = &quot;5s&quot;;var test2 = 5;console.log(isDigit(test)); // falseconsole.log(isDigit(test2)); // true 14. JS完美判断是否为网址12345678910111213141516/** * JS完美判断是否为网址 * @param strUrl URL地址 * @returns &#123;boolean&#125; 返回真或者假 * @constructor */function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125;调用方法：console.log(IsURL(&quot;https://www.notelist.cn&quot;)); // true 15. JS获取页面高度123456789101112/** * 获取页面高度 * @returns &#123;number&#125; 返回对应高度数值 */function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == &quot;BackCompat&quot; ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125;调用方法：console.log(getPageHeight()); // 例如：255 16. JS随机数时间戳1234567891011/** * JS随机数时间戳 * @returns &#123;string&#125; */function uniqueId()&#123; var a=Math.random; var b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125;调用方法：console.log(uniqueId()); // 例如：1525075670818519 17. JS时间个性化输出功能123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * JS时间个性化输出功能 * 1、&lt; 60s, 显示为“刚刚” * 2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前” * 3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX” * 4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX” * 5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX” * @param time * @returns &#123;string&#125; */function timeFormat(time)&#123; var date = new Date(time), curDate = new Date(), year = date.getFullYear(), month = date.getMonth() + 10, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), curYear = curDate.getFullYear(), curHour = curDate.getHours(), timeStr; if(year &lt; curYear)&#123; timeStr = year +&apos;年&apos;+ month +&apos;月&apos;+ day +&apos;日 &apos;+ hour +&apos;:&apos;+ minute; &#125;else&#123; var pastTime = curDate - date, pastH = pastTime/3600000; if(pastH &gt; curHour)&#123; timeStr = month +&apos;月&apos;+ day +&apos;日 &apos;+ hour +&apos;:&apos;+ minute; &#125;else if(pastH &gt;= 1)&#123; timeStr = &apos;今天 &apos; + hour +&apos;:&apos;+ minute +&apos;分&apos;; &#125;else&#123; var pastM = curDate.getMinutes() - minute; if(pastM &gt; 1)&#123; timeStr = pastM +&apos;分钟前&apos;; &#125;else&#123; timeStr = &apos;刚刚&apos;; &#125; &#125; &#125; return timeStr;&#125;调用方法：console.log(timeFormat(new Date())); // 例：刚刚 18. JS判断是否是中文名1234567891011121314151617/** * JS判断是否是中文名 * @param value * @returns &#123;boolean&#125; */function isChinese(value)&#123; var reg = /^[\\u4e00-\\u9fa5]+$/i; if (!reg.test(value)) &#123; // 不是中文名 return false; &#125; // 是中文名 return true;&#125;调用方法：console.log(isChinese(&quot;牛逼&quot;)); // true 19. JS获取地址栏参数的值1234567891011121314151617/** * JS获取地址栏参数的值 * @param name 对应的参数 * @returns &#123;*&#125; 如果有，则返回参数值，没有则返回null */function getUrlParam(name)&#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; else &#123; return null; &#125;&#125;调用方法：// 若当前的URL地址为：a.html?t1=1&amp;t2=2&amp;t3=3console.log(getUrlParam(&quot;t1&quot;)); // 1 20. JS字符串反序1234567891011/** * JS字符串反序 * @param text 需要进行反序的字符串 * @returns &#123;string&#125; 返回反序之后的字符串 * @constructor */function IsReverse(text)&#123; return text.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;调用方法：console.log(IsReverse(&quot;Hello!&quot;)); // !olleH 21. JS现金额转大写12345678910111213141516171819202122232425262728293031323334353637/** * @desc JS现金额转大写 * @param &#123;Number&#125; n * @return &#123;String&#125; */function digitUppercase(n) &#123; var fraction = [&apos;角&apos;, &apos;分&apos;]; var digit = [ &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;, &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos; ]; var unit = [ [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;], [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;] ]; var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;; n = Math.abs(n); var s = &apos;&apos;; for (var i = 0; i &lt; fraction.length; i++) &#123; s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;); &#125; s = s || &apos;整&apos;; n = Math.floor(n); for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123; var p = &apos;&apos;; for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123; p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); &#125; s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s; &#125; return head + s.replace(/(零.)*零元/, &apos;元&apos;) .replace(/(零.)+/g, &apos;零&apos;) .replace(/^整$/, &apos;零元整&apos;);&#125;调用方法：console.log(digitUppercase(1023456789.56)); // 壹拾亿贰仟叁佰肆拾伍万陆仟柒佰捌拾玖元伍角伍分 22. JS允许输入小数位的数字123456789101112/** * JS允许输入小数位的数字 * @param curObj */function clearNoFloat(curObj)&#123; curObj.value = curObj.value.replace(/[^\\d.]/g,&quot;&quot;); //清除“数字”和“.”以外的字符 curObj.value = curObj.value.replace(/^\\./g,&quot;&quot;); //验证第一个字符是数字而不是. curObj.value = curObj.value.replace(/\\.&#123;2,&#125;/g,&quot;.&quot;); //只保留第一个. 清除多余的. curObj.value = curObj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);&#125;调用方法：&lt;input type=&quot;text&quot; onkeyup=&quot;clearNoFloat(this)&quot;&gt; // JS允许输入小数位，如果是其他字符，则会替换掉 23. JS限制只能是整数123456789/** * JS限制只能是整数，不能是小数 * @param curObj */function clearNoInt(curObj)&#123; curObj.value = curObj.value.replace(/[^\\d]/g,&quot;&quot;); //清除“数字”和“.”以外的字符&#125;调用方法：&lt;input type=&quot;text&quot; onkeyup=&quot;clearNoInt(this)&quot;&gt; 24. JS检测字符串是否为空12345678910111213/** * JS检测字符串是否为空 * @param str * @returns &#123;boolean&#125; */function checkIsEmpty(str) &#123; if (null != str &amp;&amp; undefined != str &amp;&amp; &quot;&quot; != str) &#123; return false; &#125; return true;&#125;调用方法：console.log(checkIsEmpty(&quot;&quot;)); // true 25. JS将数值四舍五入到保留的小数位数1234567891011/** * 将数值四舍五入到保留的小数位数 * @param num 待四舍五入数值 * @param len 保留小数位数 * @returns &#123;number&#125; */function getRound(num,len) &#123; return Math.round(num * Math.pow(10, len)) / Math.pow(10, len);&#125;调用方法：getRound(6.123456,4); // 6.1235 26. JS切割相应小数点后位数，并将小数点后多余的0 清空123456789101112131415161718/** * 切割相应小数点后位数，并将小数点后多余的0 清空 * @param value 需要切割的数值 * @param num 需要的小数位数 * @returns &#123;string&#125; */function cutRoundNum( value , num ) &#123; var value = value.toString(); value = value.substr(0,value.indexOf(&apos;.&apos;)+1) + value.substr(value.indexOf(&apos;.&apos;)+1,num); var regx = value.match(/\\d+\\.\\d+/g); for ( var index in regx) &#123; value = value.replace(regx[index],parseFloat(regx[index])); &#125; return value;&#125;调用方法：cutRoundNum(2.333000,4); // 2.333 27. JS判断是否是邮箱的正确格式123456789101112/** * 判断是否是邮箱的正确格式 * @param str 对应的需要验证的邮箱地址 * @returns &#123;boolean&#125; 返回真或假 */function isEmail(str) &#123; var emailRegx = /^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]&#123;2,&#125;$/; return emailRegx.test(str);&#125;调用方法：isEmail(&quot;ye21st@gmail.com&quot;); // trueisEmail(&quot;ye21st!gmail.com&quot;); // false 28. JS将手机号格式化，中间部分以 * 号代替12345678910/** * JS将手机号格式化，中间部分以 * 号代替 * @param phone * @returns &#123;string | * | void&#125; */function phoneToStar( phone ) &#123; return phone.replace(/(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)/, &quot;$1****$2&quot;);&#125;调用方法：phoneToStar(&quot;16666666666&quot;); // 166****6666 29. JS银行卡卡号格式判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * JS银行卡卡号格式判断 * @param bankno * @returns &#123;boolean&#125; */function bankCardCheck(bankno) &#123; var lastNum=bankno.substr(bankno.length-1,1);//取出最后一位（与luhm进行比较） var first15Num=bankno.substr(0,bankno.length-1);//前15或18位 var newArr=new Array(); for(var i=first15Num.length-1;i&gt;-1;i--)&#123; //前15或18位倒序存进数组 newArr.push(first15Num.substr(i,1)); &#125; var arrJiShu=new Array(); //奇数位*2的积 &lt;9 var arrJiShu2=new Array(); //奇数位*2的积 &gt;9 var arrOuShu=new Array(); //偶数位数组 for(var j=0;j&lt;newArr.length;j++)&#123; if((j+1)%2==1)&#123;//奇数位 if(parseInt(newArr[j])*2&lt;9) arrJiShu.push(parseInt(newArr[j])*2); else arrJiShu2.push(parseInt(newArr[j])*2); &#125; else //偶数位 arrOuShu.push(newArr[j]); &#125; var jishu_child1=new Array();//奇数位*2 &gt;9 的分割之后的数组个位数 var jishu_child2=new Array();//奇数位*2 &gt;9 的分割之后的数组十位数 for(var h=0;h&lt;arrJiShu2.length;h++)&#123; jishu_child1.push(parseInt(arrJiShu2[h])%10); jishu_child2.push(parseInt(arrJiShu2[h])/10); &#125; var sumJiShu=0; //奇数位*2 &lt; 9 的数组之和 var sumOuShu=0; //偶数位数组之和 var sumJiShuChild1=0; //奇数位*2 &gt;9 的分割之后的数组个位数之和 var sumJiShuChild2=0; //奇数位*2 &gt;9 的分割之后的数组十位数之和 var sumTotal=0; for(var m=0;m&lt;arrJiShu.length;m++)&#123; sumJiShu=sumJiShu+parseInt(arrJiShu[m]); &#125; for(var n=0;n&lt;arrOuShu.length;n++)&#123; sumOuShu=sumOuShu+parseInt(arrOuShu[n]); &#125; for(var p=0;p&lt;jishu_child1.length;p++)&#123; sumJiShuChild1=sumJiShuChild1+parseInt(jishu_child1[p]); sumJiShuChild2=sumJiShuChild2+parseInt(jishu_child2[p]); &#125; //计算总和 sumTotal=parseInt(sumJiShu)+parseInt(sumOuShu)+parseInt(sumJiShuChild1)+parseInt(sumJiShuChild2); //计算Luhm值 var k= parseInt(sumTotal)%10==0?10:parseInt(sumTotal)%10; var luhm= 10-k; if(lastNum==luhm &amp;&amp; lastNum.length != 0)&#123; return true; &#125; else&#123; return false; &#125;&#125;调用方法：bankCardCheck(&quot;6225365271562822&quot;); // truebankCardCheck(&quot;622536527156283&quot;); // false 30. JS检查用户名是否满足要求，只能是英文或英文数字12345678910/** * JS检查用户名是否满足要求，只能是英文或英文数字 * @returns &#123;*&#125; */function checkLoginName(loginName) &#123; return /^[A-Za-z0-9]*$/.test(loginName) &amp;&amp; !/(^\\d*$)|(^\\S+\\s+\\S+$)/.test(loginName);&#125;调用方法：checkLoginName(&quot;ye21st&quot;); // truecheckLoginName(&quot;sam!&quot;); // false 31. JS验证密码，必须是字母和数字结合1234567891011/** * JS验证密码，必须是字母和数字结合 * @param password 密码 * @returns &#123;boolean&#125; 返回true或false */function checkPasswordValidate(password) &#123; return /^(?!^\\d+$)(?!^[a-zA-Z]+$)[0-9a-zA-Z]&#123;6,20&#125;$/.test(password);&#125;调用方法：checkPasswordValidate(&quot;dasdas1132156&quot;); // truecheckPasswordValidate(&quot;dsadasdas&quot;); // false 32. JS检查输入的邮政编码是否正确123456789101112131415/** * JS检查输入的邮政编码是否正确 * @param str * @returns &#123;Boolean&#125; */function checkPostcode(str)&#123; if (str.match(/^[1-9][0-9]&#123;5&#125;$/) == null) &#123; return false; &#125; else &#123; return true; &#125;&#125;调用方法：checkPostcode(&quot;423000&quot;); // truecheckPostcode(&quot;029000&quot;); // false 33. JS验证是否为正整数12345678/** * JS验证是否为正整数 * @param str * @returns */function checkNumber(str)&#123; return /^[1-9]\\d*$/.test(str);&#125; 34. JS判断浏览器12345678910111213141516171819202122/** * JS判断浏览器 * @returns &#123;string&#125; */function getOs() &#123; if (navigator.userAgent.indexOf(&quot;MSIE 8.0&quot;) &gt; 0) &#123; return &quot;MSIE8&quot;; &#125; else if (navigator.userAgent.indexOf(&quot;MSIE 6.0&quot;) &gt; 0) &#123; return &quot;MSIE6&quot;; &#125; else if (navigator.userAgent.indexOf(&quot;MSIE 7.0&quot;) &gt; 0) &#123; return &quot;MSIE7&quot;; &#125; else if (isFirefox = navigator.userAgent.indexOf(&quot;Firefox&quot;) &gt; 0) &#123; return &quot;Firefox&quot;; &#125; if (navigator.userAgent.indexOf(&quot;Chrome&quot;) &gt; 0) &#123; return &quot;Chrome&quot;; &#125; else &#123; return &quot;Other&quot;; &#125;&#125;调用方法：getOs(); // Chrome 35. JS判断浏览器1234567891011121314/** * JS手机类型判断 * @type &#123;&#123;userAgent: string, isAndroid: boolean, isIphone: boolean, isIpad: boolean, isWeixin: boolean, isChrome: boolean&#125;&#125; */var BrowserInfo = &#123; userAgent: navigator.userAgent.toLowerCase(), isAndroid: Boolean(navigator.userAgent.match(/android/ig)), isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/ig)), isIpad: Boolean(navigator.userAgent.match(/ipad/ig)), isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/ig)), isChrome:Boolean(navigator.userAgent.match(/chrome/ig)),&#125;调用方法：BrowserInfo; // android 36. JS判断是否支持css3123456789101112131415161718192021222324/** * JS判断是否支持css3 * @param &#123;string&#125; style CSS属性 * @returns */function supportCss3(style) &#123; var prefix = [&apos;webkit&apos;, &apos;Moz&apos;, &apos;ms&apos;, &apos;o&apos;], i, humpString = [], htmlStyle = document.documentElement.style, _toHumb = function (string) &#123; return string.replace(/-(\\w)/g, function ($0, $1) &#123; return $1.toUpperCase(); &#125;); &#125;; for (i in prefix) humpString.push(_toHumb(prefix[i] + &apos;-&apos; + style)); humpString.push(_toHumb(style)); for (i in humpString) if (humpString[i] in htmlStyle) return true; return false;&#125;调用方法：supportCss3(&quot;transform&quot;); // true 37. JS替换非法字符1234567891011/** * JS替换非法字符 * @param sStr * @returns &#123;string&#125; * @constructor */function URLencode(sStr) &#123; return escape(sStr).replace(/\\+/g, &apos;%2B&apos;).replace(/\\&quot;/g, &apos;%22&apos;).replace(/\\&apos;/g, &apos;%27&apos;).replace(/\\//g, &apos;%2F&apos;);&#125;调用方法：URLencode(&quot;=&quot;); // %3D 38. JS获取当前时间123456789101112131415161718192021222324/** * JS获取当前时间 * @returns &#123;string&#125; * @constructor */function GetCurrentDate() &#123; var d = new Date(); var y = d.getYear() + 1900; month = add_zero(d.getMonth() + 1), days = add_zero(d.getDate()), hours = add_zero(d.getHours()); minutes = add_zero(d.getMinutes()), seconds = add_zero(d.getSeconds()); var str = y + &apos;-&apos; + month + &apos;-&apos; + days + &apos; &apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds; function add_zero(temp) &#123; if (temp &lt; 10)&#123; return &quot;0&quot; + temp; &#125; return temp; &#125; return str;&#125;调用方法：GetCurrentDate(); // 2018-05-16 18:30:49 39. JS获取前num天的日期123456789101112131415161718192021222324/** * JS获取前num天的日期 * @param &#123;Number&#125; num 自动向上取整 * @param &#123;boolean&#125; order true是日期从大到小，false是从小到大 * @returns MM-dd */function getTodayDate(num, order = false) &#123; num = Math.ceil(num) let arr_Date = [] for (var i = 0; i &lt; num; i++) &#123; let date = new Date(new Date().getTime() - (i * 24 * 60 * 60 * 1000)) let currMonth = new Date(date).getMonth() + 1 let currDay = new Date(date).getDate() let result = `$&#123;currMonth.toString().length &lt; 2 ? `0$&#123;currMonth&#125;` : currMonth&#125;-$&#123;currDay.toString().length &lt; 2 ? `0$&#123;currDay&#125;` : currDay&#125;`; if (order) &#123; arr_Date.push(result); &#125; else &#123; arr_Date.unshift(result); &#125; &#125; return arr_Date;&#125;调用方法：getTodayDate(7); // [&quot;05-10&quot;, &quot;05-11&quot;, &quot;05-12&quot;, &quot;05-13&quot;, &quot;05-14&quot;, &quot;05-15&quot;, &quot;05-16&quot;] 40. JS XSS字符转义12345678910111213141516171819202122/** * JS XSS字符转义 * @param markup * @returns &#123;string&#125; */function replaceXSS(markup) &#123; var _ENCODE_HTML_RULES = &#123; &quot;&amp;&quot;: &quot;&amp;amp;&quot;, &quot;&lt;&quot;: &quot;&amp;lt;&quot;, &quot;&gt;&quot;: &quot;&amp;gt;&quot;, &apos;&quot;&apos;: &quot;&amp;#34;&quot;, &quot;&apos;&quot;: &quot;&amp;#39;&quot; &#125;; var _MATCH_HTML = /[&amp;&lt;&gt;&apos;&quot;]/g; function encode_char(c) &#123; return _ENCODE_HTML_RULES[c] || c; &#125;; return markup === undefined ? &apos;&apos; : String(markup).replace(_MATCH_HTML, encode_char);&#125;调用方法：replaceXSS(&quot;&lt;&gt;&quot;); // &amp;lt;&amp;gt; 41. JS 将object转为form data，方便post提交1234567891011121314151617181920/** * JS 将object转为form data，方便post提交 * @param &#123;Object&#125; obj [数据对象] * @return &#123;String&#125; */function encodeFormData(obj) &#123; if (!obj) return; var pairs = []; for (var name in obj) &#123; if (!obj.hasOwnProperty(name)) continue; if (typeof obj[name] == &apos;function&apos;) continue; var value = obj[name].toString(); name = encodeURIComponent(name.replace(&apos;%20&apos;, &apos;+&apos;)); value = encodeURIComponent(value.replace(&apos;%20&apos;, &apos;+&apos;)); pairs.push(name + &apos;=&apos; + value); &#125; return pairs.join(&apos;&amp;&apos;);&#125;调用方法：encodeFormData(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ye21st&quot;&#125;); // id=1&amp;name=ye21st 42. JS将驼峰字符串转为下划线字符串12345678910111213141516171819202122/** * JS将驼峰字符串转为下划线字符串 * @param str * @returns &#123;*&#125; */function convertCamelCase(str) &#123; if (typeof (str) != &apos;string&apos;) &#123; console.error(&apos;[convertCamelCase] argument is not String.&apos;); return str; &#125; var pattern = /[A-Z]/g; return str.replace(pattern, function(match, index) &#123; if (index != 0) &#123; return &apos;_&apos; + match.toLowerCase(); &#125; else &#123; return match.toLowerCase(); &#125; &#125;);&#125;调用方法：convertCamelCase(&quot;HelloWolrd&quot;); // hello_wolrdconvertCamelCase(1); // [convertCamelCase] argument is not String. 1 43. JS检测是否支持transition12345678910111213141516/** * JS检测是否支持transition * @returns &#123;boolean&#125; */function supportTransition () &#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r;&#125;调用方法：supportTransition(); // true 44. JS数据求交集123456789101112131415/** * JS数据求交集 * @param array1 * @param array2 * @returns &#123;*&#125; */function intersection(array1, array2) &#123; return array1.filter(function(n) &#123; return array2.indexOf(n) != -1; &#125;);&#125;调用方法：var arr1 = [1,2,3,4,5];var arr2 = [3,4,5,6,7];intersection(arr1,arr2); // [3,4,5] 45. JS Base64字符串编码与解码1234567891011121314151617181920/** * BASE64加密 * @param str * @returns &#123;string&#125; */function base64Encode(str) &#123; return btoa(unescape(encodeURIComponent(str)));&#125;/** * BASE64解密 * @param str * @returns &#123;string&#125; */function base64Decode(str) &#123; return decodeURIComponent(escape(atob(str)));&#125;调用方法：base64Encode(&quot;test&quot;); // dGVzdA==base64Decode(test); // test 46. JS判断两个数组是否相等123456789101112131415161718192021/** * JS判断两个数组是否相等 * @param &#123;Array&#125; arr1 * @param &#123;Array&#125; arr2 * @return &#123;Boolean&#125; */function arrayEqual(arr1, arr2) &#123; if (arr1 === arr2) return true; if (arr1.length != arr2.length) return false; for (var i = 0; i &lt; arr1.length; ++i) &#123; if (arr1[i] !== arr2[i]) return false; &#125; return true;&#125;调用方法：var arr1 = [1,2,3,4,5];var arr2 = [3,4,5,6,7];var arr3 = [3,4,5,6,7];var arr4 = [3,4,5,6,7];arrayEqual(arr1,arr2); // falsearrayEqual(arr3,arr4); // true 47. JS格式化${startTime}距现在的已过时间12345678910111213141516171819202122/** * JS格式化$&#123;startTime&#125;距现在的已过时间 * @param &#123;Date&#125; startTime * @return &#123;String&#125; */function formatPassTime(startTime) &#123; var currentTime = Date.parse(new Date()), time = currentTime - new Date(startTime), day = parseInt(time / (1000 * 60 * 60 * 24)), hour = parseInt(time / (1000 * 60 * 60)), min = parseInt(time / (1000 * 60)), month = parseInt(day / 30), year = parseInt(month / 12); if (year) return year + &quot;年前&quot;; if (month) return month + &quot;个月前&quot;; if (day) return day + &quot;天前&quot;; if (hour) return hour + &quot;小时前&quot;; if (min) return min + &quot;分钟前&quot;; else return &apos;刚刚&apos;;&#125;调用方法：formatPassTime(&quot;2018-5-17 10:19:00&quot;); // 1小时前 48. JS格式化现在距${endTime}的剩余时间1234567891011121314151617181920212223/** * JS格式化现在距$&#123;endTime&#125;的剩余时间 * @param &#123;Date&#125; endTime * @return &#123;String&#125; */function formatRemainTime(endTime) &#123; var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0, h = 0, m = 0, s = 0; if (t &gt;= 0) &#123; d = Math.floor(t / 1000 / 3600 / 24); h = Math.floor(t / 1000 / 60 / 60 % 24); m = Math.floor(t / 1000 / 60 % 60); s = Math.floor(t / 1000 % 60); &#125; return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;&#125;调用方法：formatRemainTime(&quot;2018-5-27 00:00:00&quot;); // 9天 12小时 2分钟 8秒 49. JS Url参数转对象123456789101112131415/** * JS Url参数转对象 * @param &#123;String&#125; url default: window.location.href * @return &#123;Object&#125; */function parseQueryString(url) &#123; url = url == null ? window.location.href : url var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1) if (!search) &#123; return &#123;&#125; &#125; return JSON.parse(&apos;&#123;&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;&#125;&apos;)&#125;调用方法：parseQueryString(&quot;http://www.baidu.com?id=1&amp;name=ye21st&quot;); // &#123;id: &quot;1&quot;, name: &quot;ye21st&quot;&#125; 50. JS过滤字符串中所有空格123456789101112131415/** * JS过滤字符串中所有空格 * @param string * @returns &#123;string&#125; */function ignoreSpaces(string) &#123; var temp = &quot;&quot;; string = &apos;&apos; + string; splitstring = string.split(&quot; &quot;); for(i = 0; i &lt; splitstring.length; i++) temp += splitstring[i]; return temp;&#125;调用方法：ignoreSpaces(&quot; a b c d e &quot;); // abcde 51. JS在字符串中查找某一字符串出现的次数123456789101112/** * JS在字符串中查找某一字符串出现的次数 * @param str * @param strSplit * @returns &#123;number&#125; */function countStr (str,strSplit)&#123; return str.split(strSplit).length-1&#125;调用方法：var strTest=&apos;sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967&apos;countStr(strTest,&quot;blog&quot;); // 6 52. JS从数组中随机获取元素1234567891011/** * JS从数组中随机获取元素 * @param arr * @returns &#123;*&#125; */function randomOne(arr) &#123; return arr[Math.floor(Math.random() * arr.length)];&#125;调用方法：var arr = [1,2,3,4,5,6,7,8,9,0];randomOne(arr); // 9 53. JS适配rem123456789101112131415161718192021222324252627282930313233/** * JS适配rem */function getFontSize()&#123; var doc=document,win=window; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; //如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px if(clientWidth&gt;750)&#123;clientWidth=750&#125; //设置根元素font-size大小 docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;; &#125;; //屏幕大小改变，或者横竖屏切换时，触发函数 win.addEventListener(resizeEvt, recalc, false); //文档加载完成时，触发函数 doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;调用方法：getFontSize();&lt;style&gt; /*使用方式很简单，比如效果图上，有张图片。宽高都是100px;*/ /*样式写法就是*/ img&#123; width:1rem; height:1rem; &#125; /*这样的设置，比如在屏幕宽度大于等于750px设备上，1rem=100px；图片显示就是宽高都是100px*/ /*比如在iphone6(屏幕宽度：375)上，375/750*100=50px;就是1rem=50px;图片显示就是宽高都是50px;*/&lt;/style&gt; 54. JS忽略大小写判断字符串是否相同123456789101112131415/** * JS忽略大小写判断字符串是否相同 * @param str1 * @param str2 * @returns &#123;boolean&#125; */function isEqualsIgnorecase(str1,str2) &#123; if(str1.toUpperCase() == str2.toUpperCase())&#123; return true; &#125;else&#123; return false; &#125;&#125;调用方法：isEqualsIgnorecase(&quot;abc&quot;,&quot;ABC&quot;); // true 55. JS忽略大小写判断字符串是否相同123456789101112131415/** * JS忽略大小写判断字符串是否相同 * @param str1 * @param str2 * @returns &#123;boolean&#125; */function isEqualsIgnorecase(str1,str2) &#123; if(str1.toUpperCase() == str2.toUpperCase())&#123; return true; &#125;else&#123; return false; &#125;&#125;调用方法：isEqualsIgnorecase(&quot;abc&quot;,&quot;ABC&quot;); // true 56. JS忽略大小写判断字符串是否相同123456789101112131415/** * JS忽略大小写判断字符串是否相同 * @param str1 * @param str2 * @returns &#123;boolean&#125; */function isEqualsIgnorecase(str1,str2) &#123; if(str1.toUpperCase() == str2.toUpperCase())&#123; return true; &#125;else&#123; return false; &#125;&#125;调用方法：isEqualsIgnorecase(&quot;abc&quot;,&quot;ABC&quot;); // true 57. JS根据文件名获取文件格式123456789101112/** * JS根据文件名获取文件格式 * @param str * @returns &#123;string&#125; */function getFileTypeByFileName(str)&#123; return str.substr(str.lastIndexOf(&quot;.&quot;)+1).toLowerCase();&#125;调用方法：getFileTypeByFileName(&quot;index.html&quot;); // htmlgetFileTypeByFileName(&quot;index.js&quot;); // jsgetFileTypeByFileName(&quot;index.php&quot;); // php 58. JS校验Ip地址格式12345678910111213/** * JS校验Ip地址格式 * @param ipvale * @returns &#123;boolean&#125; */function checkIp(ipvale) &#123; var regex = /^([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-1]\\d|22[0-3])(\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]))&#123;3&#125;$/; var b = regex.test(ipvale); return b;&#125;调用方法：checkIp(&quot;127.0.0.1&quot;); // truecheckIp(&quot;0.0.0.1&quot;); // false 59. JS生成指定位数的随机整数（可以用于短信验证码的生成）12345678910111213141516/** * JS生成指定位数的随机整数 * @param count * @returns &#123;string&#125; */function getRandomNum(count)&#123; var arr = new Array; var reNum = &quot;&quot;; for(var i=0;i&lt;count;i++)&#123; arr[i] = parseInt(Math.random()*10); reNum += String(arr[i]); &#125; return reNum;&#125;调用方法：getRandomNum(6); // 292868 60. JS判断包含关系12345678910111213141516171819202122232425262728293031/** * JS判断包含关系 * @param string 原始字符串 * @param substr 子字符串 * @param isIgnoreCase 忽略大小写 * @returns &#123;boolean&#125; */function jsContains(string,substr,isIgnoreCase)&#123; if(isIgnoreCase) &#123; string=string.toLowerCase(); substr=substr.toLowerCase(); &#125; var startChar=substr.substring(0,1); var strLen=substr.length; for(var j=0;j&lt;string.length-strLen+1;j++) &#123; if(string.charAt(j)==startChar)//如果匹配起始字符,开始查找 &#123; if(string.substring(j,j+strLen)==substr)//如果从j开始的字符与str匹配，那ok &#123; return true; &#125; &#125; &#125; return false;&#125;调用方法：jsContains(&quot;Hello World!&quot;,&quot;world&quot;); // falsejsContains(&quot;Hello World!&quot;,&quot;world&quot;,true); // true 61. JS时间戳转成时间123456789101112131415161718/** * JS时间戳转成时间 * @param time * @returns */function timeStamp2String(time)&#123; var datetime = new Date(); datetime.setTime(time); var year = datetime.getFullYear(); var month = datetime.getMonth() + 1 &lt; 10 ? &quot;0&quot; + (datetime.getMonth() + 1) : datetime.getMonth() + 1; var date = datetime.getDate() &lt; 10 ? &quot;0&quot; + datetime.getDate() : datetime.getDate(); var hour = datetime.getHours()&lt; 10 ? &quot;0&quot; + datetime.getHours() : datetime.getHours(); var minute = datetime.getMinutes()&lt; 10 ? &quot;0&quot; + datetime.getMinutes() : datetime.getMinutes(); var second = datetime.getSeconds()&lt; 10 ? &quot;0&quot; + datetime.getSeconds() : datetime.getSeconds(); return year + &quot;-&quot; + month + &quot;-&quot; + date+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;&#125;调用方法：timeStamp2String(1526552438244); // 2018-05-17 18:20:38 62. JS判断是否为空1234567891011121314151617181920/** * JS判断是否为空 * @param val * @returns &#123;boolean&#125; */function isNull(val) &#123; if (val == undefined || val == null || val == &quot;&quot; || val == &apos;&apos; || val == &quot;undefined&quot; || val == &quot;null&quot; || val == &quot;NULL&quot;) &#123; return true; &#125; return false;&#125;调用方法：isNull(undefined); // trueisNull(null); // trueisNull(&quot;&quot;); // trueisNull(&apos;&apos;); // trueisNull(&quot;undefined&quot;); // trueisNull(&quot;null&quot;); // trueisNull(&quot;NULL&quot;); // true ==内容持续更新中,敬请期待…==","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]}